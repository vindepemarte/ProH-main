Below is a â€œroadâ€‘mapâ€ of everything youâ€™ll need to touch to let a Super Agent assign a specific Super Worker to a homework, let the Super Agent set a fee per worker, and have the modal show the correct amount that should be paid.

TL;DR

DB â€“ add assigned_super_worker_id to homeworks + a perâ€‘worker fee table.
Migrations â€“ create/alter those tables.
Types â€“ update TS interfaces (Homework, User, PricingConfig).
Actions â€“ compute earnings using the workerâ€™s fee.
Context â€“ expose a helper to set the worker and fetch the fee list.
UI â€“
Settings: list all super workers â†’ edit fee.
Homework modal: show â€œAssigned Super Workerâ€ + the correct â€œSuper Worker Payâ€ and â€œProfitâ€.
Optional â€“ adjust analytics & tests.
Letâ€™s dive into each step.

1ï¸âƒ£ Database Schema Changes
a. Assign a Super Worker to a Homework
Add a nullable foreign key to the homeworks table.

ALTER TABLE homeworks
  ADD COLUMN assigned_super_worker_id UUID REFERENCES users(id);

Why nullable?
Homeworks can be created before a worker is assigned.

b. Perâ€‘Worker Fee Table
We could store the fee on the user row (fee_per_500), but that would be a single value for all workers.
Instead, keep a separate table so you can change a workerâ€™s fee without touching the user profile.

CREATE TABLE super_worker_fees (
  super_worker_id UUID PRIMARY KEY REFERENCES users(id),
  fee_per_500 NUMERIC(10,2) NOT NULL
);

Default fee â€“ on migration create a default record for every existing super worker:

INSERT INTO super_worker_fees (super_worker_id, fee_per_500)
SELECT id, 5.00 FROM users WHERE role = 'super_worker';

2ï¸âƒ£ Migrations
If youâ€™re using Flyway, Liquibase, or Prisma, add a new migration file that runs the two SQL statements above.
If youâ€™re using plain node-postgres, just drop a new file in db/migrations/ and call it during app start.

3ï¸âƒ£ TypeScript Interfaces
// src/lib/types.ts
export interface Homework {
  id: string;
  // â€¦ other fields â€¦
  assigned_super_worker_id?: string | null;
  earnings: HomeworkEarnings;
}

export interface HomeworkEarnings {
  total: number;
  agent?: number;
  super_worker?: number;
  profit: number;
}

export interface User {
  id: string;
  role: UserRole;
  // ... existing fields ...
}

export interface SuperWorkerFee {
  super_worker_id: string;
  fee_per_500: number;
}

export interface PricingConfig {
  wordTiers: Record<number, number>;
  fees: {
    agent: number;
    super_worker: number;   // **global fallback**
  };
  deadlineTiers: Record<number, number>;
}

If you already have a PricingConfig interface, just add the fees.super_worker field.

4ï¸âƒ£ Business Logic (actions.ts)
a. Helper to fetch a workerâ€™s fee
async function getWorkerFee(workerId: string): Promise<number> {
  const res = await client.query(
    'SELECT fee_per_500 FROM super_worker_fees WHERE super_worker_id = $1',
    [workerId]
  );
  return res.rows[0]?.fee_per_500 ?? pricingConfig.fees.super_worker;
}

b. Update Homework Creation
// src/lib/actions.ts
export const createHomework = async (data: CreateHomeworkPayload) => {
  const { student, ...hw } = data;
  // existing logic ...

  const assignedWorkerFee = hw.assigned_super_worker_id
    ? await getWorkerFee(hw.assigned_super_worker_id)
    : pricingConfig.fees.super_worker;

  const superWorkerPay = assignedWorkerFee * (hw.word_count / 500);
  const agentPay = agent ? (agentFeePer500 * (hw.word_count / 500)) : 0;
  const profit = finalPrice - agentPay - superWorkerPay;

  const earnings: HomeworkEarnings = {
    total: finalPrice,
    agent: agentPay > 0 ? agentPay : undefined,
    super_worker: superWorkerPay,
    profit
  };

  await client.query(
    `INSERT INTO homeworks (id, student_id, agent_id, assigned_super_worker_id,
     status, module_name, project_number, word_count, deadline, notes,
     price, earnings, created_at, updated_at)
     VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,now(),now())
     RETURNING *`,
    [
      homeworkId,
      student.id,
      agent?.id,
      hw.assigned_super_worker_id || null,
      'payment_approval',
      hw.moduleName,
      hw.projectNumber,
      hw.word_count,
      hw.deadline,
      hw.notes,
      finalPrice,
      JSON.stringify(earnings)
    ]
  );

  // â€¦ files logic â€¦
};

c. Update Homework Update (assigning/reâ€‘assigning a worker)
export const assignSuperWorkerToHomework = async (
  homeworkId: string,
  workerId: string
) => {
  const workerFee = await getWorkerFee(workerId);

  // Pull existing data
  const hwRes = await client.query(
    'SELECT word_count, price, agent_id FROM homeworks WHERE id = $1',
    [homeworkId]
  );
  const hw = hwRes.rows[0];
  if (!hw) throw new Error('Homework not found');

  // Reâ€‘calculate earnings with new worker fee
  const superWorkerPay = workerFee * (hw.word_count / 500);
  const agentPay = hw.agent_id
    ? await getAgentFee() * (hw.word_count / 500)
    : 0;
  const profit = hw.price - agentPay - superWorkerPay;

  const earnings: HomeworkEarnings = {
    total: hw.price,
    agent: agentPay > 0 ? agentPay : undefined,
    super_worker: superWorkerPay,
    profit
  };

  await client.query(
    `UPDATE homeworks
     SET assigned_super_worker_id = $1,
         earnings = $2
     WHERE id = $3`,
    [workerId, JSON.stringify(earnings), homeworkId]
  );
};

Tip: If you want a single â€œupdateâ€ endpoint that handles many fields, just extend the payload to include assigned_super_worker_id and run the same logic.

5ï¸âƒ£ Context & API Layer
Add helper functions to app-context.tsx:

// src/contexts/app-context.tsx
export const assignSuperWorker = async (
  homeworkId: string,
  workerId: string
) => {
  await client.assignSuperWorkerToHomework(homeworkId, workerId);
  // refetch homework list or update state
};

Also expose a list of super workers with fees so the settings UI can display them:

export const fetchSuperWorkerFees = async () => {
  const res = await client.query(`
    SELECT u.id, u.name, f.fee_per_500
    FROM users u
    JOIN super_worker_fees f ON u.id = f.super_worker_id
    WHERE u.role = 'super_worker'
  `);
  return res.rows;
};

And a mutation to update a workerâ€™s fee:

export const updateSuperWorkerFee = async (workerId: string, fee: number) => {
  await client.query(
    'UPDATE super_worker_fees SET fee_per_500 = $1 WHERE super_worker_id = $2',
    [fee, workerId]
  );
};

6ï¸âƒ£ UI Changes
a. Settings Tab â€“ â€œSuper Worker Feesâ€
Add a new card under the existing pricing settings:

{/* src/components/dashboard/settings-view.tsx */}
{user.role === 'super_agent' && (
  <>
    {/* ... existing cards ... */}

    <Card>
      <CardHeader>
        <CardTitle>Super Worker Fees</CardTitle>
        <CardDescription>Set the fee for each Super Worker (per 500 words).</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {superWorkerFees.map((s) => (
            <div key={s.id} className="grid grid-cols-3 gap-4 items-center">
              <span>{s.name}</span>
              <Input
                type="number"
                step="0.01"
                value={s.fee_per_500}
                onChange={(e) =>
                  handleWorkerFeeChange(s.id, parseFloat(e.target.value))
                }
              />
              <Button
                size="sm"
                onClick={() => updateSuperWorkerFee(s.id, s.fee_per_500)}
              >
                Save
              </Button>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  </>
)}

Youâ€™ll need to pull superWorkerFees from context in useEffect and maintain local state for edits.

b. Assigning a Worker to a Homework
Add a dropdown (or modal) in the homework modal when the super agent is viewing the homework:

{user.role === 'super_agent' && (
  <div className="mt-4">
    <Label>Assign Super Worker</Label>
    <Select
      value={hw.assigned_super_worker_id ?? ''}
      onChange={(e) => assignSuperWorker(hw.id, e.target.value)}
    >
      <option value="">None</option>
      {superWorkers.map((w) => (
        <option key={w.id} value={w.id}>
          {w.name}
        </option>
      ))}
    </Select>
  </div>
)}

c. Updated Financials in the Homework Modal
Replace the hardâ€‘coded super_worker fee with the one that comes from hw.earnings.super_worker:

{user.role === 'super_agent' && hw.earnings && (
  <div className="p-4 bg-primary/10 rounded-lg space-y-2 mt-4">
    <h3 className="font-bold">Financials</h3>
    <p>Revenue: Â£{Number(hw.earnings.total || 0).toFixed(2)}</p>
    {hw.earnings.agent && hw.earnings.agent > 0 && (
      <p>Agent Pay: Â£{Number(hw.earnings.agent).toFixed(2)}</p>
    )}
    <p>S.Worker Pay: Â£{Number(hw.earnings.super_worker || 0).toFixed(2)}</p>
    <p className={`font-semibold ${
      (hw.earnings.profit || 0) >= 0 ? 'text-green-600' : 'text-red-600'
    }`}>
      Profit: Â£{Number(hw.earnings.profit || 0).toFixed(2)}
    </p>
    <p>Assigned Super Worker: {hw.assigned_super_worker_name}</p>
  </div>
)}

Tip: Store the workerâ€™s name in the homework row or join it when fetching.
You can add a computed column assigned_super_worker_name or do a small JOIN when selecting.

7ï¸âƒ£ Bonus: Analytics & Tests
Analytics â€“ If you already group earnings by worker, add assigned_super_worker_id to your query.
Unit Tests â€“
Test getWorkerFee returns global fallback when no row exists.
Test createHomework calculates super_worker pay from the assigned worker.
Test assignSuperWorkerToHomework updates earnings correctly.
8ï¸âƒ£ Quick Checklist
#	What to Do	Where?
1	Add assigned_super_worker_id column	schema.sql + migration
2	Create super_worker_fees table	schema.sql + migration
3	Update TS interfaces	src/lib/types.ts
4	Add getWorkerFee, assignSuperWorkerToHomework	src/lib/actions.ts
5	Expose new context helpers	src/contexts/app-context.tsx
6	Update Settings UI for worker fees	src/components/dashboard/settings-view.tsx
7	Add worker assignment UI in modal	src/components/modals/homework-modal.tsx
8	Update financials rendering	same modal file
9	Refetch/refresh data after changes	context functions + state updates
10	Add migration scripts & tests	db/migrations/, test folder
Thatâ€™s the whole stack in a nutshell! ğŸš€

Gotchas & Things to Watch
Issue	Why it matters	Fix
Missing foreign key	If a worker gets deleted, homeworks.assigned_super_worker_id becomes orphaned	Add ON DELETE SET NULL on the FK
Fee changes after assignment	Should the existing homework keep the old fee?	Decide policy: keep old fee or reâ€‘calculate. (My code keeps the old fee unless reassigned)
Global fallback	Some workers might not have a custom fee set	getWorkerFee falls back to pricingConfig.fees.super_worker
UI performance	Pulling all workers each time can be heavy	Cache the list in context or use SWR
Next Steps
Create the migrations and run them against a dev DB.
Update your TS types and reâ€‘compile.
Add the new helper functions to your context.
Roll out the UI changes incrementally, starting with the settings card.
Test endâ€‘toâ€‘end: create a homework â†’ assign a worker â†’ check the modal â†’ ensure earnings are correct.
If you hit a snag or need more code examples (e.g., how to wire up the Select component or how to fetch the workerâ€™s name in the modal), just let me know! Happy coding! ğŸ‰